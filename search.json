[
  {
    "objectID": "notebooks/test.html",
    "href": "notebooks/test.html",
    "title": "A little math can go a long way",
    "section": "",
    "text": "sum_multiples_loop &lt;- function(N) {\n  out &lt;- 0\n  for (i in 1:N) {\n    if (i %% 3 == 0 || i %% 5 == 0) {\n      out &lt;- out + i\n    }\n  }\n  return(out)\n}\n\nsum_multiples_vectorized &lt;- function(N) {\n  if (N &lt;= 0) return(0)\n  x &lt;- seq_len(N)\n  is_divisible &lt;- x %% 3 == 0 | x %% 5 == 0\n  sum(x[is_divisible])\n}\n\nbench::mark(\n  sum_multiples_loop(1e6),\n  sum_multiples_vectorized(1e6)\n)\n\n# A tibble: 2 × 6\n  expression                           min   median `itr/sec` mem_alloc `gc/sec`\n  &lt;bch:expr&gt;                      &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;\n1 sum_multiples_loop(1e+06)        104.9ms    107ms      9.20    46.4KB    107. \n2 sum_multiples_vectorized(1e+06)   11.7ms   12.8ms     69.2     37.9MB     87.0\n\n\nseparate chunk now\n\nsum_multiples_vectorized2 &lt;- function(N) {\n  if (N &lt;= 0) return(0)\n  x &lt;- seq_len(N)\n  is_divisible &lt;- x %% 3 == 0 | x %% 5 == 0\n  sum(x[is_divisible])\n}\n\nhmm?\n\nbench::mark(\n  sum_multiples_loop(1e6),\n  sum_multiples_vectorized2(1e6)\n)\n\nWarning: Some expressions had a GC in every iteration; so filtering is\ndisabled.\n\n\n# A tibble: 2 × 6\n  expression                            min  median `itr/sec` mem_alloc `gc/sec`\n  &lt;bch:expr&gt;                       &lt;bch:tm&gt; &lt;bch:t&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;\n1 sum_multiples_loop(1e+06)         109.5ms 112.1ms      8.88        0B    117. \n2 sum_multiples_vectorized2(1e+06)   11.8ms  13.2ms     68.3     37.9MB     76.1"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Ven’s etudes",
    "section": "",
    "text": "Everything here should be considered to be in “perpetual rough draft mode” and taken with a big grain of salt. In contrast to my blog, the notebooks here are not aimed at anyone in particular aside from myself. The name etudes was inspired by Peter Norvig’s pytudes GitHub repo.\nThese are projects large and small, in which I explore new skills or interesting problems; projects that I want to preserve more than my messy ‘sandbox’ folder with various scripts, but that are not ready or intended for any type of spotlight. Some of them might eventually make it over to my blog, research projects, course materials, but most will probably enjoy the solitude and judgement-free zone that this little corner provides.\n\n\n\n\n\n\n\n\n\n   \n     \n     \n       Order By\n       Default\n         \n          Date - Oldest\n        \n         \n          Date - Newest\n        \n         \n          Notebook\n        \n     \n  \n    \n      \n      \n    \n\n\n\n\n\nNotebook\n\n\nDate\n\n\nCategories\n\n\n\n\n\n\nA little math can go a long way\n\n\n \n\n\n \n\n\n\n\nA little math can go a long way\n\n\nJan 15, 2024\n\n\nprogramming, optimizing-code\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "notebooks/optimization_exercise.html",
    "href": "notebooks/optimization_exercise.html",
    "title": "A little math can go a long way",
    "section": "",
    "text": "I’m exploring the following problem as a potential exercise for students in my Scientific Computing course:\nUnit tests\ntest &lt;- function(.f) {\n  structure(\n    list(\n      tinytest::expect_equal(.f(3), 3, info = \"Input: N = 3\"),\n      tinytest::expect_equal(.f(-100), 0, info = \"Input: N = -100\"),\n      tinytest::expect_equal(.f(20), 98, info = \"Input: N = 20\"),\n      tinytest::expect_equal(.f(6), 14, info = \"Input: N = 6\"),\n      tinytest::expect_equal(.f(0), 0, info = \"Input: N = 0\")\n    ),\n    class = \"tinytests\"\n  )\n}"
  },
  {
    "objectID": "notebooks/optimization_exercise.html#code-smell",
    "href": "notebooks/optimization_exercise.html#code-smell",
    "title": "A little math can go a long way",
    "section": "Code smell",
    "text": "Code smell\nHere is a horrible way to implement this in R:\n\nsum_multiples_loop &lt;- function(N) {\n  out &lt;- 0\n  for (i in 1:N) {\n    if (i %% 3 == 0 || i %% 5 == 0) {\n      out &lt;- out + i\n    }\n  }\n  return(out)\n}\n\nsum_multiples_loop(20)\n\n[1] 98\n\n\nIt works, but there are a ton of problems that make this code really slow and we can make it several thousand times faster by the end of this post. But it is also a good idea to test more than one case, and since I don’t want to copy paste calls to each function for many different scenarios, I have written a small suite of unit tests:\n\ntest(sum_multiples_loop)\n\n----- FAILED[data]: &lt;--&gt;\n call| test(sum_multiples_loop)\n diff| Expected '0', got '-2418'\n info| Input: N = -100\n \nShowing 1 out of 5 results: 1 fails, 4 passes fubar!\n\n\nNot surprisingly, our function fails when the input is less than 0, so this is something that we need to address later."
  },
  {
    "objectID": "notebooks/optimization_exercise.html#standard-vectorization",
    "href": "notebooks/optimization_exercise.html#standard-vectorization",
    "title": "A little math can go a long way",
    "section": "Standard vectorization",
    "text": "Standard vectorization\nWe can of course vectorize a lot and simplify the whole thing dramatically by using standard R vectorization. Instead of looping over positive integers from 1 to N, we create a vector x which stores those integers. Then we take advantage some vectorizations\n\nsum_multiples_vectorized &lt;- function(N) {\n1  if (N &lt;= 0) return(0)\n2  x &lt;- seq_len(N)\n3  is_divisible &lt;- x %% 3 == 0 | x %% 5 == 0\n4  sum(x[is_divisible])\n}\n\ntest(sum_multiples_vectorized)\n\n\n1\n\nTake care of edge cases with an early return; alternative is to give an error\n\n2\n\nseq_len(N) is a safer alternative to 1:N (doesn’t matter here because we return early if N is not-positive, but good practice in general)\n\n3\n\nBoolean operations on vectors produce vectors of TRUE and FALSE values, so no need for loops and if statements\n\n4\n\nSubseting a vector with a boolean vector will return a new vector with only those values for which is_divisible is TRUE; sum is vectorized and will return the sum of all elements in x\n\n\n\n\nAll ok, 5 results fubar!\n\n\nWe can now compare the performance of the two functions. There are many ways to do this. Here is one popular option:\n\nbench::mark(\n  sum_multiples_loop(1e6),\n  sum_multiples_vectorized(1e6)\n)\n\nWarning: Some expressions had a GC in every iteration; so filtering is\ndisabled.\n\n# A tibble: 2 × 6\n  expression                           min   median `itr/sec` mem_alloc `gc/sec`\n  &lt;bch:expr&gt;                      &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;\n1 sum_multiples_loop(1e+06)        108.9ms  112.4ms      8.85    6.85KB    104. \n2 sum_multiples_vectorized(1e+06)   11.9ms   12.8ms     69.5     37.9MB     87.3\n\n\nbut we can do the math and get much better results:\n\nsum_multiples_math &lt;- function(N) {\n  if (N &lt;= 0) {\n    return(0)\n  }\n  triangular_number &lt;- function(n) {\n    n * (n + 1) / 2\n  }\n\n  a &lt;- 3\n  b &lt;- 5\n  c &lt;- 15\n\n  a * triangular_number(floor(N / a)) +\n    b * triangular_number(floor(N / b)) -\n    c * triangular_number(floor(N / c))\n}\n\ntest(sum_multiples_math)\n\nAll ok, 5 results fubar!\n\n\ncompare to the other two functions:\n\nbench::mark(\n  sum_multiples_loop(1e6),\n  sum_multiples_vectorized(1e6),\n  sum_multiples_math(1e6)\n)\n\nWarning: Some expressions had a GC in every iteration; so filtering is\ndisabled.\n\n# A tibble: 3 × 6\n  expression                           min   median `itr/sec` mem_alloc `gc/sec`\n  &lt;bch:expr&gt;                      &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;\n1 sum_multiples_loop(1e+06)        111.7ms  113.3ms    8.74e0    6.85KB    101. \n2 sum_multiples_vectorized(1e+06)   11.9ms   12.9ms    6.84e1    37.9MB     86.0\n3 sum_multiples_math(1e+06)          615ns    697ns    1.36e6   11.52KB      0  \n\n\nof course, in all cases we can parameterize the function rather than hard-coding it. The challenge would be to find the least common multiple. You could use the function pracma::Lcm\n\nsum_series_divisors &lt;- function(N, a, b) {\n  if (N &lt;= 0) {\n    return(0)\n  }\n  triangular_number &lt;- function(n) {\n    n * (n + 1) / 2\n  }\n\n  lcm &lt;- pracma::Lcm(a, b)\n\n  a * triangular_number(floor(N / a)) +\n    b * triangular_number(floor(N / b)) -\n    lcm * triangular_number(floor(N / lcm))\n}\n\ntest(\\(x) sum_series_divisors(x, a = 3, b = 5))\n\nAll ok, 5 results fubar!\n\n\nwhich incurs a cost of course, but that cost is minuscule relative to the other approaches above:\n\nbench::mark(\n  sum_multiples_math(1e6),\n  sum_series_divisors(1e6, a = 3, b = 5)\n)\n# A tibble: 2 × 6\n  expression                            min  median `itr/sec` mem_alloc `gc/sec`\n  &lt;bch:expr&gt;                        &lt;bch:t&gt; &lt;bch:t&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;\n1 sum_multiples_math(1e+06)           615ns   697ns  1326018.    11.5KB      0  \n2 sum_series_divisors(1e+06, a = 3…   5.7µs   6.4µs   151825.   432.8KB     60.8\n\n\nbut let’s not use any libraries and write our own lcm function…"
  }
]