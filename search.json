[
  {
    "objectID": "notebooks/optimization_exercise.html",
    "href": "notebooks/optimization_exercise.html",
    "title": "A little math can go a long way",
    "section": "",
    "text": "I’m exploring the following problem as a potential exercise for students in my Scientific Computing course:\nUnit tests\ntest &lt;- function(.f) {\n  structure(\n    list(\n      tinytest::expect_equal(.f(3), 3, info = \"Input: N = 3\"),\n      tinytest::expect_equal(.f(-100), 0, info = \"Input: N = -100\"),\n      tinytest::expect_equal(.f(20), 98, info = \"Input: N = 20\"),\n      tinytest::expect_equal(.f(6), 14, info = \"Input: N = 6\"),\n      tinytest::expect_equal(.f(0), 0, info = \"Input: N = 0\")\n    ),\n    class = \"tinytests\"\n  )\n}"
  },
  {
    "objectID": "notebooks/optimization_exercise.html#code-smell",
    "href": "notebooks/optimization_exercise.html#code-smell",
    "title": "A little math can go a long way",
    "section": "Code smell",
    "text": "Code smell\nHere is a horrible way to implement this in R:\n\nsum_multiples_loop &lt;- function(N) {\n  out &lt;- 0\n  for (i in 1:N) {\n    if (i %% 3 == 0 || i %% 5 == 0) {\n      out &lt;- out + i\n    }\n  }\n  return(out)\n}\n\nsum_multiples_loop(20)\n\n[1] 98\n\n\nIt works, but there are a ton of problems that make this code really slow and we can make it several thousand times faster by the end of this post. But it is also a good idea to test more than one case, and since I don’t want to copy paste calls to each function for many different scenarios, I have written a small suite of unit tests:\n\ntest(sum_multiples_loop)\n\n----- FAILED[data]: &lt;--&gt;\n call| test(sum_multiples_loop)\n diff| Expected '0', got '-2418'\n info| Input: N = -100\n \nShowing 1 out of 5 results: 1 fails, 4 passes fubar!\n\n\nNot surprisingly, our function fails when the input is less than 0, so this is something that we need to address later."
  },
  {
    "objectID": "notebooks/optimization_exercise.html#standard-vectorization",
    "href": "notebooks/optimization_exercise.html#standard-vectorization",
    "title": "A little math can go a long way",
    "section": "Standard vectorization",
    "text": "Standard vectorization\nWe can of course vectorize a lot and simplify the whole thing dramatically by using standard R vectorization. Instead of looping over positive integers from 1 to N, we create a vector x which stores those integers. Then we take advantage some vectorizations\n\nsum_multiples_vectorized &lt;- function(N) {\n1  if (N &lt;= 0) return(0)\n2  x &lt;- seq_len(N)\n3  is_divisible &lt;- x %% 3 == 0 | x %% 5 == 0\n4  sum(x[is_divisible])\n}\n\ntest(sum_multiples_vectorized)\n\n\n1\n\nTake care of edge cases with an early return; alternative is to give an error\n\n2\n\nseq_len(N) is a safer alternative to 1:N (doesn’t matter here because we return early if N is not-positive, but good practice in general)\n\n3\n\nBoolean operations on vectors produce vectors of TRUE and FALSE values, so no need for loops and if statements\n\n4\n\nSubseting a vector with a boolean vector will return a new vector with only those values for which is_divisible is TRUE; sum is vectorized and will return the sum of all elements in x\n\n\n\n\nAll ok, 5 results fubar!\n\n\nWe can now compare the performance of the two functions. There are many ways to do this. Here is one popular option:\n\nbench::mark(\n  sum_multiples_loop(1e6),\n  sum_multiples_vectorized(1e6),\n  relative = TRUE\n)\n\nWarning: Some expressions had a GC in every iteration; so filtering is\ndisabled.\n\n# A tibble: 2 × 6\n  expression                        min median `itr/sec` mem_alloc `gc/sec`\n  &lt;bch:expr&gt;                      &lt;dbl&gt;  &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;    &lt;dbl&gt;\n1 sum_multiples_loop(1e+06)        9.67   8.97      1          NaN     1.11\n2 sum_multiples_vectorized(1e+06)  1      1         8.09       Inf     1   \n\n\nbut we can do the math and get much better results:\n\nsum_multiples_math &lt;- function(N) {\n  if (N &lt;= 0) {\n    return(0)\n  }\n  triangular_number &lt;- function(n) {\n    n * (n + 1) / 2\n  }\n\n  a &lt;- 3\n  b &lt;- 5\n  c &lt;- 15\n\n  a * triangular_number(floor(N / a)) +\n    b * triangular_number(floor(N / b)) -\n    c * triangular_number(floor(N / c))\n}\n\ntest(sum_multiples_math)\n\nAll ok, 5 results fubar!\n\n\ncompare to the other two functions:\n\nbench::mark(\n  sum_multiples_loop(1e6),\n  sum_multiples_vectorized(1e6),\n  sum_multiples_math(1e6),\n  relative = TRUE\n)\n\nWarning: Some expressions had a GC in every iteration; so filtering is\ndisabled.\n\n# A tibble: 3 × 6\n  expression                          min  median `itr/sec` mem_alloc `gc/sec`\n  &lt;bch:expr&gt;                        &lt;dbl&gt;   &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;    &lt;dbl&gt;\n1 sum_multiples_loop(1e+06)       170914. 151908.      1          NaN      Inf\n2 sum_multiples_vectorized(1e+06)  18222.  17060.      8.32       Inf      Inf\n3 sum_multiples_math(1e+06)            1       1  148783.         NaN      NaN\n\n\nof course, in all cases we can parameterize the function rather than hard-coding it. The challenge would be to find the least common multiple. You could use the function pracma::Lcm\n\nsum_series_divisors &lt;- function(N, a, b) {\n  if (N &lt;= 0) {\n    return(0)\n  }\n  triangular_number &lt;- function(n) {\n    n * (n + 1) / 2\n  }\n\n  lcm &lt;- pracma::Lcm(a, b)\n\n  a * triangular_number(floor(N / a)) +\n    b * triangular_number(floor(N / b)) -\n    lcm * triangular_number(floor(N / lcm))\n}\n\ntest(\\(x) sum_series_divisors(x, a = 3, b = 5))\n\nAll ok, 5 results fubar!\n\n\nwhich incurs a cost of course, but that cost is minuscule relative to the other approaches above:\n\nsum_series_divisors_3_5 &lt;- \\(x) sum_series_divisors(x, a = 3, b = 5)\nbench::mark(\n  sum_multiples_math(1e6),\n  sum_series_divisors_3_5(1e6),\n  relative = TRUE\n)\n# A tibble: 2 × 6\n  expression                       min median `itr/sec` mem_alloc `gc/sec`\n  &lt;bch:expr&gt;                     &lt;dbl&gt;  &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;    &lt;dbl&gt;\n1 sum_multiples_math(1e+06)        1     1         8.76       NaN     2.19\n2 sum_series_divisors_3_5(1e+06)  10.0   9.18      1          NaN     1   \n\n\nbut let’s not use any libraries and write our own lcm function"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Ven’s Etudes",
    "section": "",
    "text": "Everything here should be considered to be in “perpetual rough draft mode” and taken with a big grain of salt. In contrast to my blog, the notebooks here are not aimed at anyone in particular aside from myself. The name etudes was inspired by Peter Norvig’s pytudes GitHub repo. The are projects large and small, in which I explore new skills or interesting problems; projects that I want to preserve more than my messy ‘sandbox’ folder with various scripts, but that are not ready or intended for any type of spotlight. Some of them might eventually make it over to my blog, research projects, course materials, but most will probably enjoy the solitude and judgement-free zone that this little corner provides.\n\n\n\n\n\n\n\n\n\n   \n     \n     \n       Order By\n       Default\n         \n          Date - Oldest\n        \n         \n          Date - Newest\n        \n         \n          Notebook\n        \n     \n  \n    \n      \n      \n    \n\n\n\n\n\nNotebook\n\n\nDate\n\n\nCategories\n\n\n\n\n\n\nA little math can go a long way\n\n\nJan 15, 2024\n\n\nprogramming, optimizing-code\n\n\n\n\n\nNo matching items"
  }
]