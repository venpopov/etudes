[
  {
    "objectID": "notebooks/optimization_exercise.html",
    "href": "notebooks/optimization_exercise.html",
    "title": "Math before you code",
    "section": "",
    "text": "Problem: calculate the sum of all integers smaller or equal to N which are divisible by 3 or 5.\nExample: if N = 20, then the answer is 3+5+6+9+10+12+15+18+20 = 98\nI’m exploring this problem as a potential exercise for students in my Scientific Computing course.\nHere is a horrible way to implement this in R:\n\nsum_multiples_loop &lt;- function(N) {\n  out &lt;- 0\n  for (i in 1:N) {\n    if (i %% 3 == 0 || i %% 5 == 0) {\n      out &lt;- out + i\n    }\n  }\n  return(out)\n}\n\nsum_multiples_loop(20)\n\n[1] 98\n\ntest(sum_multiples_loop, test_cases)\n\n----- FAILED[data]: &lt;--&gt;\n call| FUN(X[[i]], ...)\n diff| Expected '0', got '-2418'\n \nShowing 1 out of 5 results: 1 fails, 4 passes fubar!\n\n\nThere are a ton of problems. And we get a failed test case when N &lt; 0.\nWe can of course vectorize a lot and simplify the whole thing dramatically:\n\nsum_multiples_vectorized &lt;- function(N) {\n  x &lt;- 1:N\n  sum(x[x %% 3 == 0 | x %% 5 == 0])\n}\n\nsum_multiples_vectorized(20)\n\n[1] 98\n\ntest(sum_multiples_vectorized, test_cases)\n\n----- FAILED[data]: &lt;--&gt;\n call| FUN(X[[i]], ...)\n diff| Mean absolute difference: 2418\n \nShowing 1 out of 5 results: 1 fails, 4 passes fubar!\n\n\nthough we still get an error for N &lt; 0. We can fix it by\n\nsum_multiples_vectorized &lt;- function(N) {\n  if (N &lt;= 0) {\n    return(0)\n  }\n  x &lt;- seq_len(N)\n  sum(x[x %% 3 == 0 | x %% 5 == 0])\n}\n\nsum_multiples_vectorized(20)\n\n[1] 98\n\ntest(sum_multiples_vectorized, test_cases)\n\nAll ok, 5 results fubar!\n\n\nwe can of course compare the speeds and marvel:\n\nbench::mark(\n  sum_multiples_loop(1e6),\n  sum_multiples_vectorized(1e6),\n  relative = TRUE\n)\n\nWarning: Some expressions had a GC in every iteration; so filtering is\ndisabled.\n\n\n# A tibble: 2 × 6\n  expression                        min median `itr/sec` mem_alloc `gc/sec`\n  &lt;bch:expr&gt;                      &lt;dbl&gt;  &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;    &lt;dbl&gt;\n1 sum_multiples_loop(1e+06)        9.82   9.39      1          NaN     1.05\n2 sum_multiples_vectorized(1e+06)  1      1         8.61       Inf     1   \n\n\nbut we can do the math and get much better results:\n\nsum_multiples_math &lt;- function(N) {\n  if (N &lt;= 0) {\n    return(0)\n  }\n  triangular_number &lt;- function(n) {\n    n * (n + 1) / 2\n  }\n\n  a &lt;- 3\n  b &lt;- 5\n  c &lt;- 15\n\n  a * triangular_number(floor(N / a)) +\n    b * triangular_number(floor(N / b)) -\n    c * triangular_number(floor(N / c))\n}\n\ntest(sum_multiples_math, test_cases)\n\nAll ok, 5 results fubar!\n\n\ncompare to the other two functions:\n\nbench::mark(\n  sum_multiples_loop(1e6),\n  sum_multiples_vectorized(1e6),\n  sum_multiples_math(1e6),\n  relative = TRUE\n)\n\nWarning: Some expressions had a GC in every iteration; so filtering is\ndisabled.\n\n\n# A tibble: 3 × 6\n  expression                          min  median `itr/sec` mem_alloc `gc/sec`\n  &lt;bch:expr&gt;                        &lt;dbl&gt;   &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;    &lt;dbl&gt;\n1 sum_multiples_loop(1e+06)       167318. 149753.      1          NaN      Inf\n2 sum_multiples_vectorized(1e+06)  17758.  16611.      8.48       Inf      Inf\n3 sum_multiples_math(1e+06)            1       1  145884.         NaN      NaN\n\n\nof course, in all cases we can parametrize the function rather than hard-coding it. The challenge would be to find the least common multiple. You could use the function pracma::Lcm\n\nsum_series_divisors &lt;- function(N, a, b) {\n  if (N &lt;= 0) {\n    return(0)\n  }\n  triangular_number &lt;- function(n) {\n    n * (n + 1) / 2\n  }\n\n  lcm &lt;- pracma::Lcm(a, b)\n\n  a * triangular_number(floor(N / a)) +\n    b * triangular_number(floor(N / b)) -\n    lcm * triangular_number(floor(N / lcm))\n}\n\ntest(\\(x) sum_series_divisors(x, a = 3, b = 5), test_cases)\n\nAll ok, 5 results fubar!\n\n\nwhich incurs a cost of course, but that cost is miniscule relative to the other approaches above:\n\nsum_series_divisors_3_5 &lt;- \\(x) sum_series_divisors(x, a = 3, b = 5)\nbench::mark(\n  sum_multiples_math(1e6),\n  sum_series_divisors_3_5(1e6),\n  relative = TRUE\n)\n\n# A tibble: 2 × 6\n  expression                       min median `itr/sec` mem_alloc `gc/sec`\n  &lt;bch:expr&gt;                     &lt;dbl&gt;  &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;    &lt;dbl&gt;\n1 sum_multiples_math(1e+06)        1     1         8.64       NaN     2.16\n2 sum_series_divisors_3_5(1e+06)  10.0   9.24      1          NaN     1   \n\n\nbut let’s not use any libraries and write our own lcm function"
  },
  {
    "objectID": "Etudes.html",
    "href": "Etudes.html",
    "title": "Etudes",
    "section": "",
    "text": "Quarto enables you to weave together content and executable code into a finished document. To learn more about Quarto see https://quarto.org.\n\n1+1\n\n[1] 2"
  },
  {
    "objectID": "Etudes.html#quarto",
    "href": "Etudes.html#quarto",
    "title": "Etudes",
    "section": "",
    "text": "Quarto enables you to weave together content and executable code into a finished document. To learn more about Quarto see https://quarto.org.\n\n1+1\n\n[1] 2"
  }
]